(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.bridge = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = require('./lib/bridge');

},{"./lib/bridge":5}],2:[function(require,module,exports){
/*
 * auction.js
 * https://github.com/richardschneider/bridge
 *
 * Copyright (c) 2016 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var bids = require('./bid');
var Contract = require('./contract');

/** The history of bids. */
function Auction(dealer, bids) {
    this.bids = [];
    this.dealer = dealer;
    if (bids) {
        bids = bids
            .split(' ')
            .filter(function (b) { return b.trim().length !== 0; });
        this.bid(bids);
    }
}

Auction.prototype.bid = function(bid) {
    var self = this, seat, contract;

    // Argument overloading
    if (arguments.length > 1) {
        bid = Array.prototype.slice.call(arguments);
    }
    if (Array.isArray(bid)) {
        bid.forEach(function(b) { self.bid(b); });
        return;
    }
    if (typeof bid === 'string' || bid instanceof String) {
        bid = bids[bid];
    }

    // Can the specified Bid be applied?
    if (this.isClosed()) {
        throw new Error('Bidding not allowed, auction is closed');
    }

    // Is the bid valid at this time in the auction
    if (bid.isPass) {
        // you can always pass
    } else if (bid.isDouble) {
        seat = this.nextSeatToBid();
        contract = this.contract();
        if (contract.declaror === undefined) {
            throw new Error('Cannot double when opposition has no contract');
        }
        if (contract.declaror === seat.partner) {
            throw new Error('Doubling your partner is not allowed');
        }
        if (contract.risk !== '') {
            throw new Error('Opposition is already at risk');
        }
    } else if (bid.isRedouble) {
        seat = this.nextSeatToBid();
        contract = this.contract();
        if (!(contract.risk === 'X' && (seat === contract.declaror || seat.partner === contract.declaror))) {
            throw new Error('Invalid bid');
        }
    } else {
        var higherBids = this.bids.some(function(b) {return b.order > bid.order;});
        if (higherBids) {
            throw new Error('Insufficient bid');
        }
    }

    // All is okay
    this.bids.push(bid);
    return bid;
};

Auction.prototype.isClosed = function() {
    if (this.bids.length < 4) {
        return false;
    }

    // Is closed, when the last three bids are a pass
    return this.bids
        .slice(-3)
        .every(function(b) { return b === bids.pass; });
};

Auction.prototype.nextSeatToBid = function() {
    if (this.isClosed()) {
        return null;
    }

    return this.bids.reduce(function(seat) { return seat.next; }, this.dealer);
};

Auction.prototype.contract = function() {
    var seat = this.dealer;
    var contract = this.bids.reduce(function(contract, bid) {
        if (bid.isPass) {

        } else if (bid.isDouble) {
            contract.risk = 'X';
        } else if (bid.isRedouble) {
            contract.risk = 'XX';
        } else {
            contract.risk = '';
            contract.level = bid.level;
            contract.denomination = bid.denomination;
            contract.declaror = seat;
        }
        seat = seat.next;
        return contract;
    }, new Contract());

    // declaror is the first partner to bid the contract's denomination
    if (contract.declaror) {
        seat = this.dealer;
        for (var i = 0; i < this.bids.length; i++) {
            var bid = this.bids[i];
            if (bid.denomination === contract.denomination && (seat === contract.declaror || seat === contract.declaror.partner)) {
                contract.declaror = seat;
                break;
            }
            seat = seat.next;
        }
    }

    return contract;
};

Auction.prototype.toString = function() {
    return this.bids.reduce(function (a, b) {
            return a + b.toString() + ' ';
        }, '')
        .trim();
};

module.exports = Auction;

},{"./bid":3,"./contract":8}],3:[function(require,module,exports){
/*
 * bid.js
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var denominationOffset = {
        'C': 1,
        'D': 2,
        'H': 3,
        'S': 4,
        'NT': 5,
    };

/***
 * A call by which a player proposes a contract that his side will win at least as many odd tricks
 * (tricks in excess of six – the book) as his bid specifies, provided the contract is
 * played at the denomination named.
 ***/
function Bid(s) {
    this.level = (+(s.charAt(0))) || undefined;
    this.denomination = this.level ? s.substr(1) : undefined;
    this.order = ((this.level - 1) * 5) + denominationOffset[this.denomination];
    this.isDouble = s === 'X';
    this.isRedouble = s === 'XX';
    this.isPass = s === '-' || s === 'P' || s === '/' || s === 'Pass';
    this.isRed = this.denomination === 'H' || this.denomination === 'D';
    this.isBlack = this.denomination === 'S' || this.denomination === 'C';
}

Bid.prototype.toString = function() {
    if (this.isPass) {
        return '-';
    } else if (this.isDouble) {
        return 'X';
    } else if (this.isRedouble) {
        return 'XX';
    }

    return this.level + this.denomination;
};

var bid = {
    '-': new Bid('-'),
    'X': new Bid('X'),
    'XX': new Bid('XX'),
    '1C': new Bid('1C'),
    '1D': new Bid('1D'),
    '1H': new Bid('1H'),
    '1S': new Bid('1S'),
    '1NT': new Bid('1NT'),
    '2C': new Bid('2C'),
    '2D': new Bid('2D'),
    '2H': new Bid('2H'),
    '2S': new Bid('2S'),
    '2NT': new Bid('2NT'),
    '3C': new Bid('3C'),
    '3D': new Bid('3D'),
    '3H': new Bid('3H'),
    '3S': new Bid('3S'),
    '3NT': new Bid('3NT'),
    '4C': new Bid('4C'),
    '4D': new Bid('4D'),
    '4H': new Bid('4H'),
    '4S': new Bid('4S'),
    '4NT': new Bid('4NT'),
    '5C': new Bid('5C'),
    '5D': new Bid('5D'),
    '5H': new Bid('5H'),
    '5S': new Bid('5S'),
    '5NT': new Bid('5NT'),
    '6C': new Bid('6C'),
    '6D': new Bid('6D'),
    '6H': new Bid('6H'),
    '6S': new Bid('6S'),
    '6NT': new Bid('6NT'),
    '7C': new Bid('7C'),
    '7D': new Bid('7D'),
    '7H': new Bid('7H'),
    '7S': new Bid('7S'),
    '7NT': new Bid('7NT'),
};
bid.Pass = bid.pass = bid['-'];
bid.Double = bid.double = bid['X'];
bid.Redouble = bid.redouble = bid['XX'];

module.exports = bid;

},{}],4:[function(require,module,exports){
/*
 * board.js
 * https://github.com/richardschneider/bridge
 *
 * Copyright (c) 2016 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var seat = require('./seat');
var Hand = require('./hand');
var PBN = require('./pbn');

var seats = [seat.north, seat.east, seat.south, seat.west];
var vuln = [
    'Nil', 'NS', 'EW', 'All',
    'NS', 'EW', 'All', 'Nil',
    'EW', 'All', 'Nil', 'NS',
    'All', 'Nil', 'NS', 'EW'
];

/*
 * Board
 */
function Board() {
    this.vulnerability = undefined;  // 'Nil', 'NS', 'EW' or 'All'
    this.dealer = undefined;  // a seat
    this.hands = {};
    this.hands[seat.north] = new Hand();
    this.hands[seat.east] = new Hand();
    this.hands[seat.south] = new Hand();
    this.hands[seat.west] = new Hand();
    this.number = 1;  // 1-relative to an event
}

/***
 * Determines if the seat is vulnerable.
 ***/
Board.prototype.isVulnerable = function(seat) {
    if (this.vulnerability === 'Nil') {
        return false;
    } else if (this.vulnerability === 'All') {
        return true;
    }
    else {
        return this.vulnerability.indexOf(seat.symbol) !== -1;
    }
};

/***
 * Set the board number and calculate dealer and vulnerability.
 ***/
Board.prototype.setNumber = function(boardNumber) {
    this.number = boardNumber;
    this.dealer = seats[(boardNumber - 1) % 4];
    this.vulnerability = vuln[(boardNumber - 1) % 16];
    return this;
};

/***
 * Get or set the deal in PBN notation.
 ***/
Board.prototype.deal = function(pbn) {
    if (arguments.length === 0) {
        return PBN.exportDeal(this.hands, this.dealer);
    }
    this.hands = PBN.importDeal(pbn);
    return this;
};

module.exports = Board;

},{"./hand":11,"./pbn":12,"./seat":13}],5:[function(require,module,exports){
/*
 * Bridge.JS
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015-2016 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var model = module.exports = {};

model.card = require('./card');
model.bid = require('./bid');
model.seat = require('./seat');

model.Competition = require('./competition');
model.Session = require('./session');
model.Contract = require('./contract');
model.Trick = require('./trick');
model.Deck = require('./deck');
model.Hand = require('./hand');
model.Auction = require('./auction');
model.Board = require('./board');
model.Game = require('./game');

model.pbn = require('./pbn');

},{"./auction":2,"./bid":3,"./board":4,"./card":6,"./competition":7,"./contract":8,"./deck":9,"./game":10,"./hand":11,"./pbn":12,"./seat":13,"./session":14,"./trick":15}],6:[function(require,module,exports){
/*
 * card.js
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var rankOffset = {
    '2': 1,
    '3': 2,
    '4': 3,
    '5': 4,
    '6': 5,
    '7': 6,
    '8': 7,
    '9': 8,
    'T': 9,
    'J': 10,
    'Q': 11,
    'K': 12,
    'A': 13
};

var suitOffset = {
    'C': 0 * 13,
    'D': 1 * 13,
    'H': 2 * 13,
    'S': 3 * 13
};

function Card(rank, suit) {
    this.rank = rank;
    this.suit = suit;
    this.order = rankOffset[this.rank] + suitOffset[this.suit];
}

Card.prototype.toString = function() {
    return this.rank + this.suit;
};

Card.imagePath = 'cards/';

Card.prototype.imageUrl = function() {
    return Card.imagePath + this.rank + this.suit + '.svg';
};

var cards = {
    all: [],
    imagePath: function(path) {
        Card.imagePath = path;
    }
};

for (var rank in rankOffset) {
    for (var suit in suitOffset) {
        var card = new Card(rank, suit);
        cards.all.push(card);
        cards[rank + suit] = card;
        cards[suit + rank] = card;
        if (rank === 'T') {
            cards['10' + suit] = card;
            cards[suit + '10'] = card;
        }
    }
}

module.exports = cards;

},{}],7:[function(require,module,exports){
/*
 * competition.js
 * https://github.com/richardschneider/bridge
 *
 * Copyright (c) 2017 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

/*
 * An organised bridge competition, sometimes called an event.
 */
function Competition() {
    this.name = '';
}

module.exports = Competition;

},{}],8:[function(require,module,exports){
/*
 * contract.js
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

/***
 * The undertaking by declarer’s side to win, at the denomination named, the number of odd tricks
 * specified in the final bid, whether undoubled, doubled or redoubled.
 ***/
function Contract() {
    this.risk = '';  // '', 'X' or 'XX'
    this.level = 0;  // 1 - 7, 0 is 'passed in'
    this.denomination = undefined; // 'S', 'H', 'D', 'C' or 'NT'
    this.declaror = undefined;  // a seat
}

Contract.prototype.toString = function() {
    if (this.isPassedIn()) {
        return '-';
    }
    return this.level +
        this.denomination +
        this.risk +
        ' by ' + this.declaror.symbol;
};

Contract.prototype.isPassedIn = function() { return this.level === 0; };
Contract.prototype.dummy = function() { return this.declaror ? this.declaror.partner : undefined; };
Contract.prototype.leader = function() { return this.declaror ? this.declaror.lho : undefined; };
Contract.prototype.isOpponent = function(seat) { return seat !== this.declaror && seat !== this.dummy(); };

module.exports = Contract;

},{}],9:[function(require,module,exports){
/*
 * deck.js
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var card = require('./card');
var seat = require('./seat');
var Hand = require('./hand');
var shuffle = require('crypto-shuffle');

/***
 * All 52 playing cards, sometimes called a pack.
 ***/
function Deck() {
    this.cards = card.all.slice();
}

/** Randomises the cards using the Fisher-Yates shuffle algorithm. */
Deck.prototype.shuffle = function() {
    shuffle(this.cards);
    return this;                        // for a fluent style.
};

/** Generates a hand for each seat. */
Deck.prototype.deal = function(dealer) {
    var player = dealer,
        hands = {};
    hands[seat.north] = new Hand();
    hands[seat.south] = new Hand();
    hands[seat.east] = new Hand();
    hands[seat.west] = new Hand();
    for (var i = 0; i < this.cards.length; ++i)
    {
        player = player.next;
        hands[player].cards.push(this.cards[i]);
    }
    hands[seat.north].sort();
    hands[seat.south].sort();
    hands[seat.east].sort();
    hands[seat.west].sort();
    return hands;
};

module.exports = Deck;

},{"./card":6,"./hand":11,"./seat":13,"crypto-shuffle":18}],10:[function(require,module,exports){
/*
 * game.js
 * https://github.com/richardschneider/bridge
 *
 * Copyright (c) 2016 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var bridge = require('./bridge');
var Auction = require('./auction');
var Contract = require('./contract');

/*
 * An organised bridge competition
 */
function Game() {
    this.auction = new Auction();
    this.contract = new Contract();
    this.tricks = [];
    this.players = {};
    this.made = undefined; // the number of tricks made over the book contract (6) or a negative number indicating the number of tricks down on the contract
}

Game.prototype.lead = function lead() {
    if (this.tricks.length === 0) {
        return undefined;
    }
    return this.tricks[0].lead();
};

Game.prototype.play = function play(card) {
   var self = this, trick, seat;

    // Argument overloading
    if (arguments.length === 0) {
        var a = [];
        this.tricks.forEach(function (trick) {
            trick.play.forEach(function(p) { a.push(p.card); });
        });
        return a;
    }
    if (arguments.length > 1) {
        card = Array.prototype.slice.call(arguments);
    }
    if (Array.isArray(card)) {
        var next;
        card.forEach(function(c) { next = self.play(c); });
        return next;
    }
    if (typeof card === 'string') {
        card = bridge.card[card];
    }

    if (this.tricks.length === 0) {
        trick = new bridge.Trick();
        this.tricks.push(trick);
        seat = this.contract.leader();
    } else {
        trick = this.tricks[this.tricks.length - 1];
        if (trick.play.length === 4) {
            seat = trick.winner(this.contract);
            trick = new bridge.Trick();
            this.tricks.push(trick);
        } else {
            seat = trick.play[trick.play.length - 1].seat.next;
        }
    }

    trick.play.push({ seat: seat, card: card});

    if (trick.play.length === 4) {
        return trick.winner(this.contract);
    }
    return seat.next;
};

module.exports = Game;

},{"./auction":2,"./bridge":5,"./contract":8}],11:[function(require,module,exports){
/*
 * hand.js
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var cards = require('./card');

/** A player's cards and inferred facts. */
function Hand() {
    this.cards = [];
    this.facts = [];
}

/** sort by descending order */
Hand.prototype.sort = function () {
    this.cards
        .sort(function (a, b) {
            return b.order - a.order;
        });
    return this;
};

Hand.prototype.cardsWithSuit = function (suit) {
    return this.cards
        .filter(function (card) {
            return card.suit === suit;
        });
};

Hand.prototype.toString = function () {
    var s = '',
        i;
    for (i = 0; i < this.cards.length; ++i) {
        if (i !== 0) {
            s += ' ';
        }
        s += this.cards[i].toString();
    }
    return s;
};

var pbnOrder = {
  S: 'H',
  H: 'D',
  D: 'C',
  C: null
};

Hand.prototype.toPBN = function () {
    if (this.cards.length === 0) {
      return '-';
    }

    var s = '',
        suit = 'S',
        i;
    this.sort();
    for (i = 0; i < this.cards.length; ++i) {
        var card = this.cards[i];
        while (card.suit !== suit) {
          s += '.';
          suit = pbnOrder[suit];
        }
        s += card.rank;
    }
    while(pbnOrder[suit] !== null) {
          s += '.';
          suit = pbnOrder[suit];
    }

    return s;
};

Hand.parsePBN = function (pbn) {
    var hand = new Hand();

    if (pbn === '-') {
        return hand;
    }
    if (pbn.split('.').length !== 4) {
      throw new Error("All four suits must be declared.");
    }

    var suit = 'S', rank, i;
    for (i = 0; i < pbn.length; ++i) {
        rank = pbn[i];
        if (rank === '.') {
            suit = pbnOrder[suit];
        } else {
          hand.cards.push(cards[rank + suit]);
        }
    }

  return hand;
};

Hand.prototype.hcp = function() {
    var points = { A: 4, K: 3, Q: 2, J: 1 };
    return this.cards.reduce(
        function(a,c) {
            return a + (points[c.rank] || 0);
        }, 0);
};

module.exports = Hand;

},{"./card":6}],12:[function(require,module,exports){
/*
 * pbn.js
 * https://github.com/richardschneider/bridge
 *
 * Copyright (c) 2016 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var seat = require('./seat');
var Hand = require('./hand');

function importDeal(pbn) {
    var deal = {};
    var dealer = seat[pbn[0]];
    var hands = pbn.slice(2).split(' ');
    var i;

    for (i = 0; i < 4; ++i) {
        deal[dealer] = Hand.parsePBN(hands[i]);
        dealer = dealer.next;
    }
    return deal;
}

function exportDeal(deal, dealer) {
    dealer = dealer || seat.south;
    var pbn = dealer.symbol + ':';
    var i;

    for (i = 0; i < 4; ++i) {
        if (i !== 0) {
            pbn = pbn + ' ';
        }
        pbn = pbn + deal[dealer].toPBN();
        dealer = dealer.next;
    }
    return pbn;
}

module.exports = {
    importDeal: importDeal,
    exportDeal: exportDeal
};

},{"./hand":11,"./seat":13}],13:[function(require,module,exports){
/*
 * seat.js
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

/*
 * Seat
 */
function Seat() {
    this.symbol = '';
}

Seat.prototype.toString = function() {
    return this.name;
};

var seat = {
    north: new Seat(),
    east: new Seat(),
    south: new Seat(),
    west: new Seat()
};

seat.north.symbol = 'N';
seat.north.name = 'north';
seat.north.partner = seat.south;
seat.north.rho = seat.west;
seat.north.lho = seat.east;
seat.north.next = seat.east;

seat.south.symbol = 'S';
seat.south.name = 'south';
seat.south.partner = seat.north;
seat.south.rho = seat.east;
seat.south.lho = seat.west;
seat.south.next = seat.west;

seat.east.symbol = 'E';
seat.east.name = 'east';
seat.east.partner = seat.west;
seat.east.rho = seat.north;
seat.east.lho = seat.south;
seat.east.next = seat.south;

seat.west.symbol = 'W';
seat.west.name = 'west';
seat.west.partner = seat.east;
seat.west.rho = seat.south;
seat.west.lho = seat.north;
seat.west.next = seat.north;

seat.N = seat.north;
seat.S = seat.south;
seat.E = seat.east;
seat.W = seat.west;

seat.distance = function (a, b) {
    if (a === b) {
        return 0;
    }
    if (a.lho === b) {
        return 1;
    }
    if (a.partner === b) {
        return 2;
    }
    return 3;
};

module.exports = seat;

},{}],14:[function(require,module,exports){
/*
 * session.js
 * https://github.com/richardschneider/bridge
 *
 * Copyright (c) 2016 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

var bridge = require('./bridge');
var pbn = require('pbn');
var Readable = require('stream').Readable;

/*
 * A period of play during which those entered in a competition play designated
 * boards against designated opponents.
 */
function Session() {
    this.competition = new bridge.Competition();
    this.site = '';
    this.date = '';
    this.boards = [];
    this.games = [];
}

Session.generateBoards = function(boardCount) {
    var session = new Session();

    for (var i = 1; i <= boardCount; ++i)
    {
        var board = new bridge.Board();
        board.setNumber(i);
        board.hands = new bridge.Deck()
            .shuffle()
            .deal(board.dealer);

        session.boards.push(board);
    }

    return session;
};

Session.importPbn = function(stream, done) {

    // Return a promise to import if `done` is not defined.
    if (!done) {
        return new Promise(function(resolve, reject) {
            Session.importPbn(stream, function(err, session) {
                if (err) {
                    reject(err);
                } else {
                    resolve(session);
                }
            });
        });
    }

    var session = new Session(), game, board;
    var vulnerabilities = {
        None: 'Nil', Love: 'Nil', '-': 'Nil',
        All: 'All', Both: 'All',
        NS: 'NS', EW: 'EW'
    };

    if (typeof stream === 'string') {
        var text = stream;
        stream = new Readable();
        stream.push(text);
        stream.push(null);
    }

    function needGame() {
        if (!game) {
            game = new bridge.Game();
            game.board = board;
            game.auction.dealer = board.dealer;
            session.games.push(game);
        }
        return game;
    }

    stream
        .pipe(pbn())
        .on('error', function(e) {
            done(e);
        })
        .on('end', function() {
            done(null, session);
        })
        .on('data', function(data) {
            if (data.type === 'game') {
                game = board = null;
            }
            else if (data.type === 'tag' && data.value !== '' && data.value !== '?') {
                if (data.name === 'Event') {
                    session.competition.name = data.value;
                } else if (data.name === 'Site') {
                    session.site = data.value;
                } else if (data.name === 'Date') {
                    session.date = data.value;
                } else if (data.name === 'Board') {
                    var number = parseInt(data.value, 10);
                    board = session.boards.find(function(b) { return b.number === number; });
                    if (!board) {
                        board = new bridge.Board();
                        board.setNumber(number);
                        session.boards.push(board);
                    }
                    if (game) {
                        game.board = board;
                    }
                } else if (data.name === 'West') {
                    needGame().players[bridge.seat.west] = data.value;
                } else if (data.name === 'North') {
                    needGame().players[bridge.seat.north] = data.value;
                } else if (data.name === 'East') {
                    needGame().players[bridge.seat.east] = data.value;
                } else if (data.name === 'South') {
                    needGame().players[bridge.seat.south] = data.value;
                } else if (data.name === 'Dealer') {
                    board.dealer = bridge.seat[data.value];
                    if (game) {
                        game.auction.dealer = board.dealer;
                    }
                } else if (data.name === 'Vulnerable') {
                    board.vulnerability = vulnerabilities[data.value];
                } else if (data.name === 'Deal') {
                    board.deal(data.value);
                } else if (data.name === 'Scoring') {
                    // TODO: Scoring
                } else if (data.name === 'Declarer') {
                    needGame().contract.declaror = bridge.seat[data.value];
                } else if (data.name === 'Contract') {
                    needGame();
                    game.contract.level = data.level;
                    game.contract.denomination = data.denomination;
                    game.contract.risk = data.risk;
                } else if (data.name === 'Result') {
                    var result = parseInt(data.value, 10);
                    var contract = needGame().contract;
                    var made = (result >= contract.level + 6) ? (result - 6) : (result - (contract.level + 6));
                    game.made = made;
                } else if (data.name === 'Auction') {
                    var auction = needGame().auction;
                    data.tokens.forEach(function(bid) {
                        if (bid === 'AP') {
                            while (!auction.isClosed()) {
                                auction.bid('Pass');
                            }
                        }
                        else if (bid === '-' || bid === '*') {
                            // ignore noise
                        }
                        else if (bid.startsWith('=')) {
                            // ignore notes
                        }
                        else {
                            auction.bid(bid);
                        }
                    });
                } else if (data.name === 'Play') {
                    var tricks = needGame().tricks;
                    var trick = new bridge.Trick();
                    tricks.push(trick);
                    var seat = bridge.seat[data.value];
                    var leader = seat;
                    data.tokens.forEach(function(card) {
                        if (card === '-' || card === '*') {
                            seat = seat.next;
                        }
                        else if (card.startsWith('=')) {
                            // ignore notes
                        }
                        else {
                            if (trick.play.length === 4) {
                                leader = trick.winner(game.contract);
                                trick = new bridge.Trick();
                                tricks.push(trick);
                            }
                            trick.play.push({ seat: seat, card: bridge.card[card]});
                            trick.play.sort(function(a, b) { return bridge.seat.distance(leader, a.seat) - bridge.seat.distance(leader, b.seat); });
                            seat = seat.next;
                        }
                    });

                }
            }
        });

    //return session;
};

module.exports = Session;

},{"./bridge":5,"pbn":17,"stream":17}],15:[function(require,module,exports){
/*
 * trick.js
 * https://github.com/richardschneider/bridgejs
 *
 * Copyright (c) 2015 Richard Schneider
 * Licensed under the MIT license.
 */

'use strict';

/**
 * The unit by which the outcome of the contract is determined, regularly
 * consisting of four cards, one contributed by each player in rotation, beginning with the
 * lead.
 **/
function Trick() {
    this.play = [];  // each object has a card and seat property.
}

/** The card played by a seat */
Trick.prototype.card = function(seat) {
    for (var i = 0; i < this.play.length; ++i) {
        if (seat === this.play[i].seat) {
            return this.play[i].card;
        }
    }

    return undefined;
};

/** The 1st seat to play a card */
Trick.prototype.leader = function() {
    return this.play.length < 1 ? undefined : this.play[0].seat;
};

/** The suit of the 1st played card */
Trick.prototype.leaderSuit = function() {
    return this.play.length < 1 ? undefined : this.play[0].card.suit;
};

/** The 1st played card */
Trick.prototype.lead = function() {
    return this.play.length < 1 ? undefined : this.play[0].card;
};

/** The seat that has won the trick */
Trick.prototype.winner = function(contract) {
    if (this.play.length < 4) {
        return undefined;
    }

    var play, bestSeat, bestOrder = -10000, order;
    var lead = this.leaderSuit();
    for (var i = 0; i < 4; ++i)
    {
        play = this.play[i];
        order = play.card.order;
        if (play.card.suit === contract.denomination) {
            order *= 1000;
        }
        else if (play.card.suit !== lead) {
            continue;
        }

        if (order > bestOrder) {
            bestOrder = order;
            bestSeat = play.seat;
        }
    }

    return bestSeat;
};

module.exports = Trick;

},{}],16:[function(require,module,exports){

},{}],17:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],18:[function(require,module,exports){
var getRandomValues = require('get-random-values');

function shuffle(a) {
   var n = a.length,                   // The number of items left to shuffle (loop invariant)
       r = new Uint8Array(n),          // Some random values
        k, t;
    getRandomValues(r);
    while (n > 1) {
        k = r[n-1] % n;                 // 0 <= k < n
        t = a[--n];                     // swap elements n and k
        a[n] = a[k];
        a[k] = t;
    }
    return a;                           // for a fluent API
}

module.exports = shuffle;
},{"get-random-values":19}],19:[function(require,module,exports){
var window = require('global/window');
var nodeCrypto = require('crypto');

function getRandomValues(buf) {
  if (window.crypto && window.crypto.getRandomValues) {
    return window.crypto.getRandomValues(buf);
  }
  if (typeof window.msCrypto === 'object' && typeof window.msCrypto.getRandomValues === 'function') {
    return window.msCrypto.getRandomValues(buf);
  }
  if (nodeCrypto.randomBytes) {
    if (!(buf instanceof Uint8Array)) {
      throw new TypeError('expected Uint8Array');
    }
    if (buf.length > 65536) {
      var e = new Error();
      e.code = 22;
      e.message = 'Failed to execute \'getRandomValues\' on \'Crypto\': The ' +
        'ArrayBufferView\'s byte length (' + buf.length + ') exceeds the ' +
        'number of bytes of entropy available via this API (65536).';
      e.name = 'QuotaExceededError';
      throw e;
    }
    var bytes = nodeCrypto.randomBytes(buf.length);
    buf.set(bytes);
    return buf;
  }
  else {
    throw new Error('No secure random number generator available.');
  }
}

module.exports = getRandomValues;

},{"crypto":16,"global/window":20}],20:[function(require,module,exports){
(function (global){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1])(1)
});